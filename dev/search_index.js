var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-API","page":"Functions","title":"Function API","text":"This page documents the function-first logging APIs exported by ComponentLogging. All functions require the logger to be passed explicitly as the first argument. In application code you will typically define forwarding helpers to avoid threading the logger manually.\n\nWhen you already have a logger available (e.g. stored in a const or a Ref), calling clog(logger, ...) bypasses the task-local logger lookup performed by stdlib logging macros (@info, @logmsg, â€¦) and can reduce overhead in hot paths.","category":"section"},{"location":"functions/#Forwarding-macro","page":"Functions","title":"Forwarding macro","text":"@forward_logger generates module-local forwarding methods (clog, clogenabled, clogf, set_log_level, with_min_level) so you can call them without explicitly passing a logger at every call site.\n\ninfo: Info\nThe function APIs do not automatically pass the current module, file, or line information; you need to provide them manually if needed. In the example below, the current module, file, and line are explicitly passed at the call site.clog(logger, :core, 0, \"hello\"; _module=@__MODULE__, file=@__FILE__, line=@__LINE__)","category":"section"},{"location":"functions/#ComponentLogging.clog","page":"Functions","title":"ComponentLogging.clog","text":"clog(logger, group, level, msg...; _module, file, line, kwargs...)\n\nEmit a log message through the given or implicit logger. group is a Symbol or NTuple{N,Symbol}. level may be LogLevel or Integer. msg can be one or more values; tuples are passed through as-is.\n\nKeyword arguments file, line, and arbitrary kwargs... are forwarded to the underlying logger sink.\n\nIf @forward_logger is already used, the following forwarding signatures are available:\n\nclog(group, level, msg...; kwargs...)\nclog(group, msg...; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"functions/#ComponentLogging.clogenabled","page":"Functions","title":"ComponentLogging.clogenabled","text":"clogenabled(logger, group, level) -> Bool\nclogenabled(logger, group) -> Bool\n\nReturn whether logging is enabled for the given logger, group, and level. If level is omitted, Info is used.\n\nIf @forward_logger is already used, the following forwarding signatures are available:\n\nclogenabled(group, level) -> Bool\nclogenabled(group) -> Bool\n\n\n\n\n\n","category":"function"},{"location":"functions/#ComponentLogging.clogf","page":"Functions","title":"ComponentLogging.clogf","text":"clogf(f::Function, logger, group, level; _module, file, line)\n\nLike clog, but accepts a zero-argument function f that is only invoked if logging is enabled for the specified group and level. If f() returns nothing, no message is emitted. Non-tuple returns are converted to a tuple internally.\n\nIf @forward_logger is already used, the following forwarding signatures are available:\n\nclogf(f, group, level; _module, file, line)\n\n\n\n\n\n","category":"function"},{"location":"functions/#ComponentLogging.@forward_logger","page":"Functions","title":"ComponentLogging.@forward_logger","text":"@forward_logger logger\n\nDefine forwarding methods in the current module so you can call clog, clogf, clogenabled, set_log_level, and with_min_level without explicitly passing a logger each time.\n\nlogger may be either an AbstractLogger or a Base.RefValue{<:AbstractLogger}.\n\nExample:\n\nusing ComponentLogging\n\nconst pkg_logger = Ref(ComponentLogger(...))\n@forward_logger pkg_logger\n\nclog(:core, 0, \"hello\")\nclogf(:core, 0) do\n    (\"expensive \", 1 + 2)\nend\nset_log_level(:core, 1000)\nwith_min_level(2000) do\n    # Temporarily raise the global minimum level (fast early rejection).\n    clog(:core, 0, \"suppressed by global min\")\nend\n\nNote: Use this macro at module top-level.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#Macros-API","page":"Macros","title":"Macros API","text":"This page documents the macro-first logging APIs exported by ComponentLogging.\n\nMacros work differently from functions. Macros do not take a logger as an argument; instead, you need to bind a key-value pair of current module => logger to the internal module registry of ComponentLogging. Subsequent macro calls do not require passing the logger; the logger for the current module is retrieved via a dictionary lookup.\n\nYou can use set_module_logger or @bind_logger in the __init__ function to bind the logger to the current module.\n\nfunction __init__()\n    set_module_logger(@__MODULE__, logger)\nend\n# or\nfunction __init__()\n    @bind_logger sink=logger\nend\n\ninfo: Info\nMacros automatically capture the caller's module, file, and line number.","category":"section"},{"location":"macros/#ComponentLogging.set_module_logger","page":"Macros","title":"ComponentLogging.set_module_logger","text":"set_module_logger(mod::Module, logger::AbstractLogger) -> String\n\nBind logger to the module mod. Returns a short human-readable string summary \"<Module> <- <LoggerType>\".\n\n\n\n\n\n","category":"function"},{"location":"macros/#ComponentLogging.get_logger","page":"Macros","title":"ComponentLogging.get_logger","text":"get_logger(mod::Module) -> AbstractLogger\n\nReturn the logger bound to module mod, walking up parent modules if necessary. Throws an error if none is found at the root.\n\n\n\n\n\n","category":"function"},{"location":"macros/#ComponentLogging.@bind_logger","page":"Macros","title":"ComponentLogging.@bind_logger","text":"@bind_logger [sink=...] [rules=...] [mod=...]\n\nBind a ComponentLogger to the given mod (default: caller's module). Arguments must be passed as keywords. rules may be any AbstractDict mapping groups (Symbol or NTuple{N,Symbol}) to levels (LogLevel or Integer).\n\nReturns the constructed ComponentLogger.\n\nExample:\n\n@bind_logger sink=ConsoleLogger() rules=Dict(:__default__=>Info, :core=>Warn)\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@clog","page":"Macros","title":"ComponentLogging.@clog","text":"@clog [group] level msg...\n\nMacro version of clog that captures the caller's Module, file, and line for accurate provenance. group must be a literal Symbol or tuple of literal symbols.\n\nExample:\n\n@clog 0 \"hello\"             # default group\n@clog :core 1000 \"hello\"    # single group (literal)\n@clog (:a,:b) 2000 \"hello\"  # specified group (literal)\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@cdebug","page":"Macros","title":"ComponentLogging.@cdebug","text":"@cdebug args...\n\nShorthand for @clog Debug args.... Emits a message at Debug level. See @clog for argument rules and caller metadata capture.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@cinfo","page":"Macros","title":"ComponentLogging.@cinfo","text":"@cinfo args...\n\nShorthand for @clog Info args.... Emits a message at Info level. See @clog for argument rules and caller metadata capture.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@cwarn","page":"Macros","title":"ComponentLogging.@cwarn","text":"@cwarn args...\n\nShorthand for @clog Warn args.... Emits a message at Warn level. See @clog for argument rules and caller metadata capture.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@cerror","page":"Macros","title":"ComponentLogging.@cerror","text":"@cerror args...\n\nShorthand for @clog Error args.... Emits a message at Error level. See @clog for argument rules and caller metadata capture.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@clogenabled","page":"Macros","title":"ComponentLogging.@clogenabled","text":"@clogenabled group level\n\nMacro that expands to a boolean expression answering whether logging is enabled for the literal group and level at the call site (using the logger bound to the caller's module). group must be a literal Symbol or tuple of literal symbols.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@clogf","page":"Macros","title":"ComponentLogging.@clogf","text":"@clogf [group] level expr\n\nMacro version of clogf. The last argument can be either a message expression or a zero-argument function (e.g. () -> begin ...; \"message\" end). The body is only evaluated if logging is enabled. Caller module and source location are captured automatically.\n\n\n\n\n\n","category":"macro"},{"location":"common_types/#Common-Types","page":"Common Types","title":"Common Types","text":"","category":"section"},{"location":"common_types/#ComponentLogging.ComponentLogging","page":"Common Types","title":"ComponentLogging.ComponentLogging","text":"ComponentLogging\n\nModule-scoped logging utilities for Julia built on top of the stdlib Logging. This package provides:\n\nA ComponentLogger with hierarchical rule keys to control log levels per component path, e.g. (:net, :http).\nLightweight functions clog, clogenabled, clogf for emitting messages and checking if logging is enabled.\nMacros @clog, @clogf, @clogenabled that capture the caller module/source location for accurate provenance.\nMacro @forward_logger to generate module-local forwarding methods.\nA simple PlainLogger sink for pretty, colored output without timestamps/prefixes.\n\nTypical usage:\n\nusing ComponentLogging\n\nrules = Dict(\n    :core => Info,\n    :io => Warn,\n    :net => Debug\n)\nclogger = ComponentLogger(rules; sink=PlainLogger())\n\nclog(clogger, :core, Info, \"something happened\")\n\n\n\n\n\n","category":"module"},{"location":"common_types/#ComponentLogging.ComponentLogger","page":"Common Types","title":"ComponentLogging.ComponentLogger","text":"ComponentLogger(; sink=ConsoleLogger(Debug))\nComponentLogger(rules::AbstractDict; sink=ConsoleLogger(Debug))\n\nA logger that delegates to an underlying sink (AbstractLogger) while applying component-based minimum level rules. Rules are defined on paths of symbols (NTuple{N,Symbol}). A lookup walks up the path and falls back to (:__default__,).\n\nsink: the underlying AbstractLogger that actually handles messages.\nrules: mapping from NTuple{N,Symbol} to LogLevel. The default entry ((DEFAULT_SYM,), Info) is created automatically when needed.\n\nThe effective minimum level is the minimum of all values in rules, cached in the min field for fast checks.\n\n\n\n\n\n","category":"type"},{"location":"common_types/#ComponentLogging.PlainLogger","page":"Common Types","title":"ComponentLogging.PlainLogger","text":"PlainLogger(; stream=Base.CoreLogging.closed_stream, min_level=Info)\n\nA simple AbstractLogger implementation that prints messages without standard prefixes/timestamps, with minimal coloring by level.\n\nstream::IO: target stream; if closed, falls back to stderr.\nmin_level::LogLevel: minimum enabled level for the sink.\n\nIntended for tests, demos, or embedding in custom sinks.\n\n\n\n\n\n","category":"type"},{"location":"common_types/#ComponentLogging.set_log_level!","page":"Common Types","title":"ComponentLogging.set_log_level!","text":"set_log_level!(logger, group, lvl) -> ComponentLogger\n\nSet or update the minimum level for a specific component group on logger. group may be a Symbol or a NTuple{N,Symbol} tuple; lvl can be LogLevel or Integer. If lvl is a Bool, it is treated as a simple switch: true sets the rule to Info and false sets it to LogLevel(1) (which disables the default clogenabled(logger, group) check). Updates the internal min cache appropriately.\n\n\n\n\n\n","category":"function"},{"location":"common_types/#ComponentLogging.with_min_level","page":"Common Types","title":"ComponentLogging.with_min_level","text":"with_min_level(f, logger, lvl)\n\nTemporarily set logger.min to lvl while executing f(), restoring the original value afterward even if an exception is thrown.\n\n\n\n\n\n","category":"function"},{"location":"#ComponentLogging","page":"Home","title":"ComponentLogging","text":"Documentation for ComponentLogging.\n\nModules = [ComponentLogging]\nOrder   = [:type, :function, :macro]","category":"section"}]
}
