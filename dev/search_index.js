var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-API","page":"Functions","title":"Function API","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"This page documents the function-first logging APIs exported by ComponentLogging. All functions require the logger to be passed explicitly as the first argument. In application code you will typically define forwarding helpers to avoid threading the logger manually.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"info: Info\nThe function APIs do not automatically pass the current module, file, or line information; you need to provide them manually if needed. In the example below, the current module, file, and line are explicitly passed at the call site.clog(logger, :core, 0, \"hello\"; _module=@__MODULE__, file=@__FILE__, line=@__LINE__)","category":"page"},{"location":"functions/#ComponentLogging.clog","page":"Functions","title":"ComponentLogging.clog","text":"clog(logger, [group], level, msg...; _module, file, line, kwargs...)\n\nEmit a log message through the given or implicit logger. group is a Symbol or NTuple{N,Symbol}. If omitted, the default group (DEFAULT_SYM,) is used. level may be LogLevel or Integer. msg can be one or more values; tuples are passed through as-is.\n\nKeyword arguments file, line, and arbitrary kwargs... are forwarded to the underlying logger sink.\n\nIt is recommended to create a forwarding function to implicitly pass the logger:\n\nclog(args...; kwargs...) = clog(logger, args...; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"functions/#ComponentLogging.clogenabled","page":"Functions","title":"ComponentLogging.clogenabled","text":"clogenabled(logger, [group], level) -> Bool\n\nReturn whether logging is enabled for the given group and level using the given or implicit module-bound logger.\n\nIt is recommended to create a forwarding function to implicitly pass the logger:\n\nclogenabled(group, level) = clogenabled(logger, group, level)\n\n\n\n\n\n","category":"function"},{"location":"functions/#ComponentLogging.clogf","page":"Functions","title":"ComponentLogging.clogf","text":"clogf(f::Function, logger, [group], level; _module, file, line)\n\nLike clog, but accepts a zero-argument function f that is only invoked if logging is enabled for the specified group and level. If f() returns nothing, no message is emitted. Non-tuple returns are converted to a tuple internally.\n\nIt is recommended to create a forwarding function to implicitly pass the logger:\n\nclogf(f, group, level; kwargs...) = clogf(f, logger, group, level; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"macros/#Macros-API","page":"Macros","title":"Macros API","text":"","category":"section"},{"location":"macros/","page":"Macros","title":"Macros","text":"This page documents the macro-first logging APIs exported by ComponentLogging.","category":"page"},{"location":"macros/","page":"Macros","title":"Macros","text":"Macros work differently from functions. Macros do not take a logger as an argument; instead, you need to bind a key-value pair of current module => logger to the internal module registry of ComponentLogging. Subsequent macro calls do not require passing the logger; the logger for the current module is retrieved via a dictionary lookup.","category":"page"},{"location":"macros/","page":"Macros","title":"Macros","text":"You can use set_module_logger or @bind_logger in the __init__ function to bind the logger to the current module.","category":"page"},{"location":"macros/","page":"Macros","title":"Macros","text":"function __init__()\n    set_module_logger(@__MODULE__, logger)\nend\n# or\nfunction __init__()\n    @bind_logger logger\nend","category":"page"},{"location":"macros/","page":"Macros","title":"Macros","text":"info: Info\nMacros automatically capture the caller's module, file, and line number.","category":"page"},{"location":"macros/#ComponentLogging.set_module_logger","page":"Macros","title":"ComponentLogging.set_module_logger","text":"set_module_logger(mod::Module, logger::AbstractLogger) -> String\n\nBind logger to the module mod. Returns a short human-readable string summary \"<Module> <- <LoggerType>\".\n\n\n\n\n\n","category":"function"},{"location":"macros/#ComponentLogging.get_logger","page":"Macros","title":"ComponentLogging.get_logger","text":"get_logger(mod::Module) -> AbstractLogger\n\nReturn the logger bound to module mod, walking up parent modules if necessary. Throws an error if none is found at the root.\n\n\n\n\n\n","category":"function"},{"location":"macros/#ComponentLogging.@bind_logger","page":"Macros","title":"ComponentLogging.@bind_logger","text":"@bind_logger [sink=...] [rules=...] [min=...] [module=...]\n\nBind a ComponentLogger to the given module (default: caller's module). Arguments must be passed as keywords. rules may be a full Dict of rule keys. If min is omitted, it is derived from rules[(DEFAULT_SYM,)].\n\nReturns the constructed ComponentLogger.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@clog","page":"Macros","title":"ComponentLogging.@clog","text":"@clog [group] level msg...\n\nMacro version of clog that captures the caller's Module, file, and line for accurate provenance. group must be a literal Symbol or tuple of literal symbols.\n\nExample:\n\n@clog 0 \"hello\"             # default group\n@clog :core 1000 \"hello\"    # single group (literal)\n@clog (:a,:b) 2000 \"hello\"  # specified group (literal)\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@cdebug","page":"Macros","title":"ComponentLogging.@cdebug","text":"@cdebug args...\n\nShorthand for @clog Debug args.... Emits a message at Debug level. See @clog for argument rules and caller metadata capture.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@cinfo","page":"Macros","title":"ComponentLogging.@cinfo","text":"@cinfo args...\n\nShorthand for @clog Info args.... Emits a message at Info level. See @clog for argument rules and caller metadata capture.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@cwarn","page":"Macros","title":"ComponentLogging.@cwarn","text":"@cwarn args...\n\nShorthand for @clog Warn args.... Emits a message at Warn level. See @clog for argument rules and caller metadata capture.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@cerror","page":"Macros","title":"ComponentLogging.@cerror","text":"@cerror args...\n\nShorthand for @clog Error args.... Emits a message at Error level. See @clog for argument rules and caller metadata capture.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@clogenabled","page":"Macros","title":"ComponentLogging.@clogenabled","text":"@clogenabled group level\n\nMacro that expands to a boolean expression answering whether logging is enabled for the literal group and level at the call site (using the logger bound to the caller's module). group must be a literal Symbol or tuple of literal symbols.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#ComponentLogging.@clogf","page":"Macros","title":"ComponentLogging.@clogf","text":"@clogf [group] level expr\n\nMacro version of clogf. The last argument can be either a message expression or a zero-argument function (e.g. () -> begin ...; \"message\" end). The body is only evaluated if logging is enabled. Caller module and source location are captured automatically.\n\n\n\n\n\n","category":"macro"},{"location":"common_types/#Common-Types","page":"Common Types","title":"Common Types","text":"","category":"section"},{"location":"common_types/#ComponentLogging.ComponentLogging","page":"Common Types","title":"ComponentLogging.ComponentLogging","text":"ComponentLogging\n\nModule-scoped logging utilities for Julia built on top of the stdlib Logging. This package provides:\n\nA ComponentLogger with hierarchical rule keys to control log levels per component path, e.g. (:net, :http).\nLightweight functions clog, clogenabled, clogf for emitting messages and checking if logging is enabled.\nMacros @clog, @clogf, @clogenabled that capture the caller module/source location for accurate provenance.\nA simple PlainLogger sink for pretty, colored output without timestamps/prefixes.\n\nTypical usage:\n\nusing ComponentLogging\n\nrules = Dict(\n    :core => Info, \n    :io => Warn, \n    :net => Debug\n)\nclogger = ComponentLogger(rules; sink=PlainLogger())\n\nclog(clogger, :core, Info, \"something happened\")\n\n\n\n\n\n","category":"module"},{"location":"common_types/#ComponentLogging.ComponentLogger","page":"Common Types","title":"ComponentLogging.ComponentLogger","text":"ComponentLogger(; sink=ConsoleLogger(Debug))\nComponentLogger(rules::AbstractDict; sink=ConsoleLogger(Debug))\n\nA logger that delegates to an underlying sink (AbstractLogger) while applying component-based minimum level rules. Rules are defined on paths of symbols (NTuple{N,Symbol}). A lookup walks up the path and falls back to (:__default__,).\n\nsink: the underlying AbstractLogger that actually handles messages.\nrules: mapping from NTuple{N,Symbol} to LogLevel. The default entry ((DEFAULT_SYM,), Info) is created automatically when needed.\n\nThe effective minimum level is the minimum of all values in rules, cached in the min field for fast checks.\n\n\n\n\n\n","category":"type"},{"location":"common_types/#ComponentLogging.PlainLogger","page":"Common Types","title":"ComponentLogging.PlainLogger","text":"PlainLogger(stream::IO, min_level::LogLevel=Info)\nPlainLogger(min_level::LogLevel=Info)\n\nA simple AbstractLogger implementation that prints messages without standard prefixes/timestamps, with minimal coloring by level.\n\nstream: target stream; if closed, falls back to stderr.\nmin_level: minimum enabled level for the sink.\n\nIntended for tests, demos, or embedding in custom sinks.\n\n\n\n\n\n","category":"type"},{"location":"common_types/#ComponentLogging.set_log_level!","page":"Common Types","title":"ComponentLogging.set_log_level!","text":"set_log_level!(logger, group, lvl) -> ComponentLogger\n\nSet or update the minimum level for a specific component group on logger. group may be a Symbol or a NTuple{N,Symbol} tuple; lvl can be LogLevel or Integer. Updates the internal min cache appropriately.\n\n\n\n\n\n","category":"function"},{"location":"common_types/#ComponentLogging.with_min_level","page":"Common Types","title":"ComponentLogging.with_min_level","text":"with_min_level(f, logger, lvl)\n\nTemporarily set logger.min to lvl while executing f(), restoring the original value afterward even if an exception is thrown.\n\n\n\n\n\n","category":"function"},{"location":"#ComponentLogging","page":"Home","title":"ComponentLogging","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ComponentLogging.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ComponentLogging]\nOrder   = [:type, :function, :macro]","category":"page"}]
}
